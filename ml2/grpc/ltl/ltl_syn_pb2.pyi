"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import ml2.grpc.aiger.aiger_pb2
import ml2.grpc.ltl.ltl_mc_pb2
import ml2.grpc.ltl.ltl_pb2
import ml2.grpc.mealy.mealy_pb2
import ml2.grpc.system.system_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _LTLSynStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _LTLSynStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LTLSynStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    LTLSYNSTATUS_UNSPECIFIED: _LTLSynStatus.ValueType  # 0
    """Default Value, additional Information should be given if set on purpose"""
    LTLSYNSTATUS_REALIZABLE: _LTLSynStatus.ValueType  # 1
    """Signals that the LTL Specification was found to be realizable"""
    LTLSYNSTATUS_UNREALIZABLE: _LTLSynStatus.ValueType  # 2
    """Signals that the LTL Specification was found to be unrealizable"""
    LTLSYNSTATUS_ERROR: _LTLSynStatus.ValueType  # 3
    """Signals that some error happened during computation. Additional
    information should be given.
    """
    LTLSYNSTATUS_TIMEOUT: _LTLSynStatus.ValueType  # 4
    """Signals that the synthesis timed out."""
    LTLSYNSTATUS_NONSUCCESS: _LTLSynStatus.ValueType  # 5
    """Signals that synthesis was not successful, However no error and timeout
    happened. Additional Information should be given.
    """

class LTLSynStatus(_LTLSynStatus, metaclass=_LTLSynStatusEnumTypeWrapper):
    """Mirrors ml2.ltl.ltl_syn.ltl_syn_status.LTLSynStatus"""

LTLSYNSTATUS_UNSPECIFIED: LTLSynStatus.ValueType  # 0
"""Default Value, additional Information should be given if set on purpose"""
LTLSYNSTATUS_REALIZABLE: LTLSynStatus.ValueType  # 1
"""Signals that the LTL Specification was found to be realizable"""
LTLSYNSTATUS_UNREALIZABLE: LTLSynStatus.ValueType  # 2
"""Signals that the LTL Specification was found to be unrealizable"""
LTLSYNSTATUS_ERROR: LTLSynStatus.ValueType  # 3
"""Signals that some error happened during computation. Additional
information should be given.
"""
LTLSYNSTATUS_TIMEOUT: LTLSynStatus.ValueType  # 4
"""Signals that the synthesis timed out."""
LTLSYNSTATUS_NONSUCCESS: LTLSynStatus.ValueType  # 5
"""Signals that synthesis was not successful, However no error and timeout
happened. Additional Information should be given.
"""
global___LTLSynStatus = LTLSynStatus

class _LTLRealStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _LTLRealStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LTLRealStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    LTLREALSTATUS_UNSPECIFIED: _LTLRealStatus.ValueType  # 0
    """Default Value, additional Information should be given if set on purpose"""
    LTLREALSTATUS_REALIZABLE: _LTLRealStatus.ValueType  # 1
    """Signals that the LTL Specification was found to be realizable"""
    LTLREALSTATUS_UNREALIZABLE: _LTLRealStatus.ValueType  # 2
    """Signals that the LTL Specification was found to be unrealizable"""

class LTLRealStatus(_LTLRealStatus, metaclass=_LTLRealStatusEnumTypeWrapper):
    """Mirrors ml2.ltl.ltl_real_status.LTLRealStatus"""

LTLREALSTATUS_UNSPECIFIED: LTLRealStatus.ValueType  # 0
"""Default Value, additional Information should be given if set on purpose"""
LTLREALSTATUS_REALIZABLE: LTLRealStatus.ValueType  # 1
"""Signals that the LTL Specification was found to be realizable"""
LTLREALSTATUS_UNREALIZABLE: LTLRealStatus.ValueType  # 2
"""Signals that the LTL Specification was found to be unrealizable"""
global___LTLRealStatus = LTLRealStatus

@typing_extensions.final
class LTLSynProblem(google.protobuf.message.Message):
    """An LTL synthesis problem. Used as Request message for Synthesis"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key", b"key", "value", b"value"]) -> None: ...

    PARAMETERS_FIELD_NUMBER: builtins.int
    DECOMP_SPECIFICATION_FIELD_NUMBER: builtins.int
    FORMULA_SPECIFICATION_FIELD_NUMBER: builtins.int
    SYSTEM_FORMAT_FIELD_NUMBER: builtins.int
    @property
    def parameters(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Defines run- and tool-specific parameters. As Map (Dict in Python).
        Typical examples are threads, timeouts etc. Can be empty.
        """
    @property
    def decomp_specification(self) -> ml2.grpc.ltl.ltl_pb2.DecompLTLSpecification: ...
    @property
    def formula_specification(self) -> ml2.grpc.ltl.ltl_pb2.LTLSpecification: ...
    system_format: ml2.grpc.system.system_pb2.System.ValueType
    def __init__(
        self,
        *,
        parameters: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
        decomp_specification: ml2.grpc.ltl.ltl_pb2.DecompLTLSpecification | None = ...,
        formula_specification: ml2.grpc.ltl.ltl_pb2.LTLSpecification | None = ...,
        system_format: ml2.grpc.system.system_pb2.System.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["decomp_specification", b"decomp_specification", "formula_specification", b"formula_specification", "specification", b"specification"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["decomp_specification", b"decomp_specification", "formula_specification", b"formula_specification", "parameters", b"parameters", "specification", b"specification", "system_format", b"system_format"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["specification", b"specification"]) -> typing_extensions.Literal["decomp_specification", "formula_specification"] | None: ...

global___LTLSynProblem = LTLSynProblem

@typing_extensions.final
class LTLSynSolution(google.protobuf.message.Message):
    """An LTL Synthesis solution. Used as response message for Synthesis."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CIRCUIT_FIELD_NUMBER: builtins.int
    MEALY_MACHINE_FIELD_NUMBER: builtins.int
    REALIZABLE_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    DETAILED_STATUS_FIELD_NUMBER: builtins.int
    TOOL_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def circuit(self) -> ml2.grpc.aiger.aiger_pb2.AigerCircuit: ...
    @property
    def mealy_machine(self) -> ml2.grpc.mealy.mealy_pb2.MealyMachine: ...
    realizable: builtins.bool
    """Shows, whether the specification was found to be realizable or
    unrealizable. May not be set, e.g. if a timeout happened.
    """
    status: global___LTLSynStatus.ValueType
    """A status that includes useful information about the run. For some status
    values, additional information should be given in detailed_status.
    """
    detailed_status: builtins.str
    """Here additional information should be supplied if the status value requires
    more details. For example an error trace for ERROR or a reason for
    NONSUCCESS
    """
    tool: builtins.str
    """tool that created the response"""
    @property
    def time(self) -> google.protobuf.duration_pb2.Duration:
        """How long the tool took to create the result."""
    def __init__(
        self,
        *,
        circuit: ml2.grpc.aiger.aiger_pb2.AigerCircuit | None = ...,
        mealy_machine: ml2.grpc.mealy.mealy_pb2.MealyMachine | None = ...,
        realizable: builtins.bool | None = ...,
        status: global___LTLSynStatus.ValueType = ...,
        detailed_status: builtins.str = ...,
        tool: builtins.str = ...,
        time: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_realizable", b"_realizable", "_time", b"_time", "circuit", b"circuit", "mealy_machine", b"mealy_machine", "realizable", b"realizable", "system", b"system", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_realizable", b"_realizable", "_time", b"_time", "circuit", b"circuit", "detailed_status", b"detailed_status", "mealy_machine", b"mealy_machine", "realizable", b"realizable", "status", b"status", "system", b"system", "time", b"time", "tool", b"tool"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_realizable", b"_realizable"]) -> typing_extensions.Literal["realizable"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_time", b"_time"]) -> typing_extensions.Literal["time"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["system", b"system"]) -> typing_extensions.Literal["circuit", "mealy_machine"] | None: ...

global___LTLSynSolution = LTLSynSolution

@typing_extensions.final
class NeuralLTLSynSolution(google.protobuf.message.Message):
    """An LTL Synthesis solution. Used as response message for Synthesis through a
    neural solver.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SYNTHESIS_SOLUTION_FIELD_NUMBER: builtins.int
    MODEL_CHECKING_SOLUTION_FIELD_NUMBER: builtins.int
    TOOL_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    @property
    def synthesis_solution(self) -> global___LTLSynSolution: ...
    @property
    def model_checking_solution(self) -> ml2.grpc.ltl.ltl_mc_pb2.LTLMCSolution:
        """A model-checking result can optionally be included in the response,
        certifying that the solution is correct. Needs to be set if the system is
        not known to be correct.
        """
    tool: builtins.str
    """Tool that created the response"""
    @property
    def time(self) -> google.protobuf.duration_pb2.Duration:
        """How long the tool took to create the result."""
    def __init__(
        self,
        *,
        synthesis_solution: global___LTLSynSolution | None = ...,
        model_checking_solution: ml2.grpc.ltl.ltl_mc_pb2.LTLMCSolution | None = ...,
        tool: builtins.str = ...,
        time: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_model_checking_solution", b"_model_checking_solution", "_time", b"_time", "model_checking_solution", b"model_checking_solution", "synthesis_solution", b"synthesis_solution", "time", b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_model_checking_solution", b"_model_checking_solution", "_time", b"_time", "model_checking_solution", b"model_checking_solution", "synthesis_solution", b"synthesis_solution", "time", b"time", "tool", b"tool"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_model_checking_solution", b"_model_checking_solution"]) -> typing_extensions.Literal["model_checking_solution"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_time", b"_time"]) -> typing_extensions.Literal["time"] | None: ...

global___NeuralLTLSynSolution = NeuralLTLSynSolution

@typing_extensions.final
class NeuralLTLSynSolutionSpecPair(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DECOMP_SPECIFICATION_FIELD_NUMBER: builtins.int
    FORMULA_SPECIFICATION_FIELD_NUMBER: builtins.int
    SOLUTION_FIELD_NUMBER: builtins.int
    @property
    def decomp_specification(self) -> ml2.grpc.ltl.ltl_pb2.DecompLTLSpecification: ...
    @property
    def formula_specification(self) -> ml2.grpc.ltl.ltl_pb2.LTLSpecification: ...
    @property
    def solution(self) -> global___NeuralLTLSynSolution:
        """The solution form the Neural Synthesis Tool."""
    def __init__(
        self,
        *,
        decomp_specification: ml2.grpc.ltl.ltl_pb2.DecompLTLSpecification | None = ...,
        formula_specification: ml2.grpc.ltl.ltl_pb2.LTLSpecification | None = ...,
        solution: global___NeuralLTLSynSolution | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["decomp_specification", b"decomp_specification", "formula_specification", b"formula_specification", "solution", b"solution", "specification", b"specification"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["decomp_specification", b"decomp_specification", "formula_specification", b"formula_specification", "solution", b"solution", "specification", b"specification"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["specification", b"specification"]) -> typing_extensions.Literal["decomp_specification", "formula_specification"] | None: ...

global___NeuralLTLSynSolutionSpecPair = NeuralLTLSynSolutionSpecPair
