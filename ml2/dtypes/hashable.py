"""Abstract Hashable class"""

import logging
from abc import abstractmethod
from typing import Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Hashable(object):
    _unique_id_value: Optional[str] = None

    def __init__(self, unique_id: Optional[str] = None) -> None:
        self._unique_id_value = unique_id

    def unique_id(self, catch_error: bool = False) -> Optional[str]:
        """Shows a unique identifier for this object. Either initialized or generated by its content dynamically.

        Returns:
            Optional[str]: hexadecimal value of an unique identifier. None if there is no identifier.
        """
        if self._unique_id_value is not None:
            return self._unique_id_value
        elif catch_error:
            try:
                return f"{self.cr_hash:x}"
            except Exception as e:
                print("Error when creating unique id. Ignored!", e.__class__.__name__)
                return None
        else:
            return f"{self.cr_hash:x}"

    @property
    @abstractmethod
    def cr_hash(self) -> int:
        """A hash method that has collision resistance.
        Should be implemented for all child classes at some point.

        For 2 objects a, b it holds:
        a == b <-> cr_hash(a) == cr_hash(b)

        Returns:
            int: a hash of the obj.
        """
        raise NotImplementedError
